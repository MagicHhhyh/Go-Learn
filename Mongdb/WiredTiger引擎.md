# Mongo引擎WiredTiger介绍
MongoDB的存储原理与其所使用的存储引擎紧密相关。自MongoDB 3.2版本起，WiredTiger成为了默认的存储引擎。WiredTiger是一个高性能、支持事务的存储引擎，它结合了B树索引和LSM树（Log-Structured Merge Tree）的优点，为MongoDB提供了出色的读写性能。

具体来说，WiredTiger通过其B树索引结构实现了快速的数据检索。同时，它利用LSM树的设计原理，将数据首先写入内存中的数据结构（memtable，实际上这个数据结构是B+树，但是他并不固定，在其他引擎中跳表可以，红黑也是可以），随后在合适的时机将这些数据合并到磁盘上的持久化存储中。这种设计使得WiredTiger能够高效地处理大量的写入操作，特别适用于需要高写入性能的应用场景（当然，我们牺牲了读取效率）。

# LSM
将数据先写到内存，或者在内存中修改，然后等到内存中数据到达一定数量级，就可以把该数据结构写入到磁盘当中，需要注意的是，写入到磁盘中以后，我们存储的结构就不是之前内存中的结构，而是*SSTable（Sorted String Table）*，顾名思义，sstable就是有序字符串的键值对。而我们对sstable的管理其实就是LSM树。
## Compaction sstable的合并
我们可能会有很多版本的sstable，当他满足一定条件，其实就是给sstable划分的等级，每个等级规定只能有一定数量的sstable，这些sstable都是有序的，但是他们之间可不是，一但数量超过，就会与下一层有交集的进行合并，然后扔到下一级吗，当然条件不止一个，我是指出一个比较重要的情况。

再来讲讲什么是合并操作吧，我们会选定一些sstable，然后执行合并操作，这个操作包括了删除旧的数据，同时依旧保证新的sstable有序，很简单就像归并排序。

这样也降低了我们查找时候需要翻阅的sstable数量

## Memtable
这里讲讲B+树（有的MongoDB的引擎用的跳表但是WiredTiger不是），B+树增删改查都是有的。添加毫无疑问，插入一条key-value，删除则是给指定数据打上一个删除标记，毕竟真的删除又要动内存空间太麻烦了，也没必要，在后续写入sstable的时候不写他就完事了。修改，常规操作改就完事了。而查找呢，我们会先从内存中的memtable去查找，然后按照低等级到高等级的sstable去查找（最新的是0级），找到了，那么就是最新的指定数据。

## 事务
WiredTiger 支持多文档 ACID 事务，这是 MongoDB 4.0 及以后版本的一个重要特性。这意味着 WiredTiger 可以处理跨多个文档的原子操作。

WiredTiger 存储引擎支持多种事务隔离级别，主要是以下三种：

读未提交（Read-Uncommitted）：允许事务读取到其他未提交事务的更改，这可能导致脏读（Dirty Read），即一个事务读取了另一个事务未提交的数据。

读已提交（Read-Committed）：事务只能读取到其他事务已经提交的更改，这种隔离级别可以避免脏读，但仍然可能遇到不可重复读（Nonrepeatable Read），即在同一事务中，多次读取同一数据集合时可能会得到不同的结果。

快照隔离（Snapshot Isolation）：这是 WiredTiger 的默认事务隔离级别。它通过为每个事务创建一个一致性快照来提供一致的视图，确保事务在整个过程中看到的数据是一致的，从而避免了不可重复读和幻读（Phantom Read）现象。

也是通过MVCC（版本控制）实现的事务。和mysql那套基本一样的。